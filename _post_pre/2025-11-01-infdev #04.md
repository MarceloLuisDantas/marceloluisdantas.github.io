---
layout: post
title: "Infdev #04 - Ponteiros em C."
categories: [C, Ponteiros]
tags: [C, Ponteiros]
---

No ultimo post (Infdev #03 - Memória RAM e Endereços.), nos falamos sobre como a memoria funciona. Agora, vamos entender como C lidar com ponteiros (E não C++ neste caso, pois C++ possui diferentes formas de lidar com ponteiros), e sobre alguns fatores importantes que acabam sendo ignorados por materiais menos aprofundados. 

> Aviso: não irei falar sobre o uso de ponteiros para alocar memoria na heap, pois o proximo post sera justamente sobre stack vs heap, e eu acredito que entender stack vs heap é mais facil apos entender o uso de ponteiros.

## O que é um ponteiros?
Um ponteiro em C é um tipo, um tipo para designar variaveis/constantes que invês de armazenar um valor, armazenam um endereço de memoria. Por exemplo:

```c
#include <stdio.h>

int main() {
    int       foo = 10;
    int *ponteiro = &foo; // & indica que queremos o endereço de memoria de foo, e não o valor armazenado em foo   
                          // * indica que a variavel guarda um endereço de memoria

    printf("               Valor guardado em `foo`: %d\n", foo);
    printf("     Endereço de memoria de para `foo`: %p\n", &foo);
    printf("          Valor guardado em `ponteiro`: %p\n", ponteiro);
    printf("Endereço de memoria de para `ponteiro`: %p\n", &ponteiro);

    return 0;
}
```

Este exemplo, cria um valor na memoria nomeado `foo`, com valor de 10. E em seguida criamos um ponteiro que armazena para foo. Explicando melhor a sintaxe da criação de ponteiros: `int *ponteiro = &foo` pode parecer complicado, porem tal como `int foo` cria um valor na memoria que armazena um inteiro, `int *ponteiro` cria um valor na memoria que armazena um endereço de memoria de um inteiro, e não um inteiro. E sim, como o ponteiro é uma variavel como qualquer outra, o valor que armazena o ponteiro, também possui um endereço de memoria que pode ser armazenado em um ponteiro caso você queira
```c
int main() {
    int       foo = 10;
    int       *p1 = &foo;
    int      **p2 = &p1;
    int     ***p3 = &p2;
    int    ****p4 = &p3;
    ...
```
> Existem varios casos onde o uso de ponteiros que apontam para outros ponteiros é util, para lidar com matrizes ou listas de strings, mas isso fica para outros posts.
{: .prompt-tip }

Algo importante a se notar sobre a declaração de ponteiros, é que o indicador de ponteiro `*` deve ficar junto ao nome da variavel, e não ao tipo.
```c
int main() {
    int valor = 10;
    
    int *foo = &valor; // ✅
    int* bar = &valor; // ❌
}
```
A sintaxe não esta errado, e vai compilar normalmente, porem é importante manter o `*` junto ao nome, para ficar claro ao leitor que `foo` é um ponteiro, e isso pode confundir, pois em casos de declara multiplos ponteiros:
```c
int main() {
    int *foo1, *foo2, *foo3, ...; // ✅
    int*  bar,  bar2,  bar3, ...; // ❌
}
```
Pode dar a entender que todos os `bar`s são ponteiros para inteiros, sendo que apenas o primeiro é um ponteiro, e os outros são apenas um inteiro, e não um ponteiro para um inteiro.

## Referência e Dereferência (Reference and Dereference)
Explicação rapida da sintaxe e significado desses 2 termos. 

### & Operador de Referência(Reference):
```c
int main() {
    int valor = 10;
    int *ponteiro = &x;
}
```
& é o operador utilizado indicar que queremos o endereço de memoria de um valor, e não o seu valor. 

### * Operador de Dereferência(Dereference):
```c
int main() {
    int valor = 10;
    int *ponteiro = &x;

    int valor_2 = *ponteiro + 20;
    printf("Valor 2: %d\n"); // 30
}
```
\* é o oeprador que é utilizado para indicar que um valor é um ponteiro, porem ele é um dos poucos operadores em C que possui mais de um uso. No caso, ao ser utilizado na declaração de um valor `int *ponteiro` ela indica ao compilador que `ponteiro` possui um endereço de memoria para um inteiro. Porem o endereço de memoria guardado em ponteiro é um valor como qualquer outro, e caso você tente fazer `int valor_2 = ponteiro + 20`, o seu codigo não vai compilar, pois ponteiro é um endereço de memoria para um inteiro, e não um inteiro, par acessar o inteiro que esta no endereço de memoria guardado em `ponteiro`, usamos o operador de Dereferência *. Utilizar * antes de qualquer ponteiro, indica que queremos o valor que esta guardado no endereço de memoria do ponteiro, e não o endereço de memoria. 

Existem outras formas de dereferenciar um ponteiro, como por exemplo, acessar o index de um array com `[]`, sempre que você esta fazer `lista[3]`, por de baixo dos panos, esta acontecendo uma dereferenciação, isso sera mais explicado em breve.


## Uso
O principal uso de ponteiros, é permite acesso a um valor sem precisar mover ou duplica, como por exemplo, para lidar com listas grandes:
```c
int sum(int *x, int len) {
    int total = 0;
    for (int i = 0; i < len; i++)
        total += x[i];
    return total;
}

void square(int *x, int len) {
    for (int i = 0; i < len; i++)
        x[i] = x[i] * x[i];
}

void print_lista(int *x, int len) {
    printf("Lista: ");
    for (int i = 0; i < len; i++)
        printf("%d ", x[i]);
    printf("\n");
}

int main() {
    int lista[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int len = sizeof(lista)/sizeof(int); // sizeof(lista) indica o tamanho da lista em bytes, sizeof(int) diz o tamanho de um int em bytes
     
    int total = sum(&lista[0], len); // & indica que quermos o endereço de memoria de lista[0]. e não o valor
    print_lista(&lista[0], len);     // Lista: 1 2 3 4 5 6 7 8 9 10
    printf("Total = %d\n", total);   // Total = 55
    
    square(&lista[0], len);

    int total_quadrado = sum(&lista[0], len);
    print_lista(&lista[0], len);            // Lista: 1 4 9 16 25 36 49 64 81 100 
    printf("Total = %d\n", total_quadrado); // Total = 385
    return 0;
}
```
Neste exemplo, temos uma lista de inteiros com varios valores, e queremos fazer coisas com ela, printar todos os elementos, somar os elementos, operar sobre os elementos... Nessas operações, o uso de ponteiros serve principalmente para economizar memoria, pois caso não fosse utilizado ponteiros, sempre que uma função fosse chamada, uma nova copia do array seria criada, e seria passada para a função como parametro. E especilamente no caso de operar sobre os elementos da lista, o ponteiro é utilizado para acessar o valor original, e não uma copia, pois queremos editar a lista original, e não gerar uma nova, com ponteiros é possivel.

Agora, algo que pode esta confuso, é a sintaxe de passar o ponteiro do primeiro elemento, invês da lista, e as funções recebem um ponteiro de um inteiro, e não de uma lista de inteiros, e é agora que vamos falar do principal aspecto de ponteiros que custuma ser ignorada, ou mal explicada, artimetica de ponteiros.

## Aritmética de ponteiro
Você já se perguntou o porque de indexes de arrays começarem em 0 e não em 1? Isso é por calsa de como arrays são armazenados na memoria e pela Aritmética de ponteiro. Vamos lembrar do que foi dito no ultimo post, o Infedev #03 sobre memoria, a memoria é um grande array, e os ponteiros são endereços de memoria que servem de index para este array. O endereço de memoria é apenas um numero, e apenas isso, um numero muito grande em hexadecimal, mas um numero, e como qualquer outro numero, podemos realizar somas e subtrações (as outras operações são possiveis, mas não são uteis). Quando um conjunto de valores são alocados na memoria, seja um array, ou uma estrutura, todos os valores deste conjunto sera alocados sequencialmente, um seguido do outro, sem espaços vazios entre os elementos. 
```c 
int main() {

    int lista[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    return 0;
}
```

Quando a lista foo é alocada na memoria, os 10 elementos seram colocados na memoria de forma sequencial, por exemplo, o primeiro elemento esta alocado em 0xFF00, como o tipo int em C possui 4 bytes, o segundo elemento estara na posição 0xFF04, o terceiro no endereço 0xFF08, o proximo em 0xFF0C e assim por diante. 
```c 
void square(int *x, int len) {
    for (int i = 0; i < len; i++)
        x[i] = x[i] * x[i];
}

int main() {

    int lista[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    square(&lista[0], len);

    return 0;
}
```

A sintaxe de &lista[0] pode ser meio confusa, e realmente é sem o contexto, e se você utilizar &lista, invês de &lista[0], vai funcionar, porem o compilador vai te dar um warning, pois a função square espera receber um ponteiro para um int, &lista é um ponteiro para int[10]. Ao passar um ponteiro para o primeiro valor da lista, junto ao tamanho da lista, nos sabemos quantos valores a lista tem, e podemos ir somando 4 (tamanho em bytes de um int) a cada etapa para acessar os proximos elementos. Agora, algo que precisa ser explicado e a sintaxe de acesso a elementos de um array. A sintaxe de lista[index], so funciona se soubermos o tipo dos valores armazenados em lista, e o tamanho de cada valor, e a forma com que o index é acessado, é multiplicado index pelo tamanho, e somando o primeiro endereço de memoria de lista. Por exemplo:
```c
int main() {
    int lista[] = {1, 2, 3, 4};
    lista[2] = 50; 
}
```
Vamos supor que a lista esta alocado do endereço 0xFF00, nos sabemos que é uma lista int's, e sabemos que um int possui 4 bytes, nos queremos o index 2 (terceiro elemento), para acessar o index desejado, pegamos o endereço incial do array (o endereço a qual esta o primeiro elemento/index 0), e somamos com 4 * index: 0xFF00 + (4 * 2) = 0xFF00 + 8 = 0xFF08. Logo, o index 2(terceiro elemento), esta no endereço 0xFF08. Esse comportamento gera algumas consequencias, uma delas é a velocidade, arrays são tão mais rapidos que qualquer outra estrutura de dados justamente pq podemos acesar qualquer valor dele diretamente, apenas realizando uma multiplicação e uma soma. E uma segunda consequencia, é o motivo de que o primeiro elemento de um array é o 0 e não o 1, pois o primeiro já esta no endereço inicial do array. E também é por isso tudo, que ao acessar um index de um array, acontece uma dereferenciação, pois como explicado anteriormente, para acessar o valor deum endereço de memoria, precisamos dereferenciar ele, e como explicado agora, um index de uma lista, é apenas o endereço de memoria inicial + algum valor.

Algo importante a se dar foco é a questão do tamanho do dado a qual o ponteiro aponta. No exemplo da lista, o ponteiro aponta para um int, que possui 4 bytes de tamanho, porem um ponteiro pode apontar para qualquer literalmente coisa na memoria, independete do tipo, seja um um valor primitido como int ou float, seja uma estrutura com varios valores dentro, podemos ate ter ponteiros para funções. Como dito anteriormente o ponteiro sempre tera o mesmo tamanho, porem o valor apontado pode variar.

```c
typedef struct Context {
    int eip; // 4 bytes        
    int esp; // 4 bytes       
    int ebx; // 4 bytes       
    int ecx; // 4 bytes       
    int edx; // 4 bytes       
    int esi; // 4 bytes       
    int edi; // 4 bytes       
    int ebp; // 4 bytes       
    int pc;  // 4 bytes   
} Context;   // 36 bytes

int main() {
    Context  c = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    Context *p = &p;
    
    printf("Tamanho de Context: %d\n", sizeof(c));              // 36
    printf("Tamanho de Ponteiro de Context: %d\n", sizeof(p));  // 8
    
    return 0;
}
```

Neste exemplo, a estrutura Context ocupa 36 bytes na memoria, porem o ponteiro ocupa apenas 8 como esperado. Caso queira criar uma lista de Context, basta criar tal como criamos uma lista de ints, o compilador ira se encarregar de realizar a aritmetria para acessar qualquer valor indexado.

```c
typedef struct Context {
    int eip; // 4 bytes        
    int esp; // 4 bytes       
    int ebx; // 4 bytes       
    int ecx; // 4 bytes       
    int edx; // 4 bytes       
    int esi; // 4 bytes       
    int edi; // 4 bytes       
    int ebp; // 4 bytes       
    int pc;  // 4 bytes   
} Context;   // 36 bytes

int main() {
    Context contextos[] = { ... };
    ...

    contextos[3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    ...
    return 0;
}
```

## Ponteiros de funções
Assim como qualquer outra coisa no seu programa, funções estão carregadas na memoria, estando em algum lugar na memoria, podemos acessar esse lugar com o endereço de memoria correto, portanto, podemos utilizar ponteiros para funções. A sintaxe de ponteiros para funções é um pouco diferente, quase sempre funções precisam parametros, por exemplo:

```c
int soma(int x, int y) {
    return x + y;
}

int mult(int x, int y) {
    return x * y;
}
```

Ambas funções soma e mult recebem 2 inteiros e retornam um inteiro, por mais que elas possuam corpos diferentes, porem oq importa para ponteiros, é apenas o tipo de retorno, e os tipos dos parametros. Para mostrar, vamos voltar ao exemplo anterior da lista.

```c
#include <stdio.h>

int soma_20(int x) {
    return x + 20;
}

int quadrado(int x) {
    return x * x; 
}

void apply(int *x, int len, int (*fun)(int)) {
    for (int i = 0; i < len; i++)
        x[i] = fun(x[i]);
}

void print_lista(int *x, int len) {
    printf("Lista: ");
    for (int i = 0; i < len; i++)
        printf("%d ", x[i]);
    printf("\n");
}

int main() {
    int lista[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int len = sizeof(lista)/sizeof(int); // sizeof(lista) indica o tamanho da lista em bytes, sizeof(int) diz o tamanho de um int em bytes
     
    print_lista(&lista[0], len);      // Lista: 1 2 3 4 5 6 7 8 9 10
    
    apply(&lista[0], len, &quadrado);
    print_lista(&lista[0], len);      // Lista: 1 4 9 16 25 36 49 64 81 100 

    apply(&lista[0], len, &soma_20);
    print_lista(&lista[0], len);      // Lista: 21 24 29 36 45 56 69 84 101 120 

    return 0;
}
```

As funções soma_20 e quadrado, ambas recebem um int e retornam um int, ea função apply recebe uma lista de inteiros, o tamanho da lista, e um ponteiros para uma função que recebe um inteiro e reotrna um inteiro: int (*fun)(int), o primeiro int é o tipo de retorno, (\*fun) é o nome do parametro, e diz que é um ponteiro, (int) indica que a função recebe apenas um inteiro como parametro.

### POO?
Talvez tenha vindo na sua cabeça utilizar isso para fazer algo como um objeto, usando estruturas com ponteiro de funções para servi de metodos, e da pra fazer algo parecido:
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct Pessoa {
    char *nome;
    int idade;
    char *(*toString)(struct Pessoa*);
    void (*free)(struct Pessoa*);
} Pessoa;

char *toStringPessoa(Pessoa *p) {
    // +1 para o caracteres nulo \0 no final da string
    int tamanho = snprintf(NULL, 0, "Nome: %s\nIdade: %d", p->nome, p->idade) + 1;
    
    char *resultado = malloc(tamanho);
    if (!resultado) return NULL;
    
    snprintf(resultado, tamanho, "Nome: %s\nIdade: %d", p->nome, p->idade);
    return resultado;
}

void freePessoa(Pessoa *p) {
    free(p->nome);
    free(p);
    p = NULL;
}

// Metodo construtor
Pessoa *newPessoa(char *nome, int idade) {
    Pessoa *p = malloc(sizeof(Pessoa)); 
    if (!p) return NULL;

    p->nome = malloc(strlen(nome) + 1);
    memcpy(p->nome, nome, strlen(nome) + 1);

    p->idade = idade;
    p->toString = toStringPessoa;
    p->free = freePessoa;

    return p;
}

int main() {
    Pessoa *p1 = newPessoa("Marceline", 23);
    if (!p1) return -1;

    printf("%s\n", p1->toString(p1));
    p1->free(p1);
    return 0;
}
```
Sim eu sei, outras linguagens que são feitas para serem orientadas a objetos possuem sintaxe muito melhor, porem isso é apenas uma prova de conceito para como ponteiro para funções podem ser uteis, e como você pode ter um certo nivel de polimorfismo, pois você pode ter diferentes funções que se comportam de diferentes formas, porem possuem um mesmo objetivo, e você utilizar elas tal como em um objeto, sem precisar lembrar qual o nome da versão especifica para esta estrutura.

## Casting de ponteiros
Algo que eu tentei deixar claro ao longo do post, é como ponteiros não possuem tamanhos diferentes, todo ponteiros vai ter o mesmo temanho, no caso de uma maquina 64 bits, um ponteiro tem 8 bytes (64 bits). O tipo de um ponteiro, indica qual o tamanho na memoria do valor a qual ele aponta, um `long *p` é um ponteiro que aponta para um valor de 8 bytes(long é um int64 em C para maquinas 64 bits), um `short *p` é um ponteiro que aponta para um valor de 2 byte. No exemplo anteior do objeto `Pessoa`, `Pessoa *p1 = newPessoa("Marceline", 23);`, `p1` é um ponteiro que aponta para um valor do 32 bytes, pois:
```c
typedef struct Pessoa {
    char *nome;                         // Ponteiro = 8 bytes
    int idade;                          // Int = 4 bytes
    // 4 bytes de padding para alinhamento (explicarei em outro post)
    char *(*toString)(struct Pessoa*);  // Ponteiro = 8 bytes
    void (*free)(struct Pessoa*);       // Ponteiro = 8 bytes
} Pessoa; // 8 + 4 + 4 + 8 + 8 = 32 bytes                  

```
Como toString e free são ponteiros para funções, não é possivel saber qual o tamanho deles de forma convencional apenas pelo tipo do ponteiro. 

Em C é possivel realizar a conversão (casting) de tipos de ponteiros, o uso disso é bem menos obvio e não muito util, e de fato são poucos os cenarios mudar o tipo do ponteiro ira ter um uso onde realmente essa é a unica forma de resolver. Um desses senarios a qual casting de ponteiros é a unica solução, é o famoso algoritmo de raiz quadrada inversa de quake, que eu irei fazer um post falando sobre. Mas em resumo, um