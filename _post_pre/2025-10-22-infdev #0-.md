---
layout: post
title: "C é uma linguagem facil, se você souber faze-la ser."
categories: [C, C++]
tags: [C, C++]
---

ABS: Sempre que me referir a C, considere também C++ no meio.

C é uma linguagem criada em 1972 e até hojé é utilizada mesmo com tantas propostas de novas linguagens para "Matar o C". A viabilidade de todas elas é questionavel a partir do momento a qual elas precisão criar ABI's para se comunicar com bibliotecas em C. Eu não gosto de utilizar a questão da existencia de codigo legado como argumento para se aprender C ou para criar novos projetos em C, se não eu não seria o maior advogado da adoção de Nim para desenvolvimento de sistemas. Porem ao mesmo tempo ignorar tudo esta escrito em C é ignorar 90% das coisas que são uteis em computação, se não diretamente, indiretamente. Você pode não ter escrito uma linha linha de C na sua vida, mas ainda assim você esta em cima de uma muralha codigo em C. Se você usa Python, Python é escrito em C, e quase todas as libs importantes de Python são feitas em C: NumPy; PyTorch; Pandas; Kivy... Se JavaScript for o seu caso, o seu navegador com 90% de chanche é escrito em C; Node é escrito em C; Sim, o Deno é escrito em Rust, porém Rust possui toda sua infraestrutura construida em cima de libs C. Criptografia; Segurança; Computação Grafica; Servidores Web; tudo que é importante é escrito em C ou sustentado por coisas escritas em C.

Certo, agora sabemos que o mundo é escrito em C, ou depende de coisas escritas em C. Porem eu serei o ultimo a dizer que C é uma linguagem facil de ser utilizar quando se quer fazer qualquer coisa mais complexa que uma calculadora. Porem são mais de 50 anos no qual C é uma linguagem dificil, e são mais de 50 anos que as pessoas sofrem com os problemas de C(O motivo de C ser tão dificil é o motivo que torna C tão utilizado, explicarei em outro post), e são mais de 50 anos de material e ferramental criado para ajudar a amezinar os problemas, você ainda tera os problemas, porem sera muito mais facil debugar para encontra-los e resolve-los. Algumas dessas ferramentas são simples e com 0 custo adicional para utilizar, enquanto outras já exigem um pouco de tempo para aprender.

## Editor de Texto/IDE
Esse é o menos importante dos pontos que quero tratar hojé. A sua escolha de editor de texto pode parecer inrelevante, e realmente é, ate certo ponto. C é uma das linguagens conhecidas por precisar de um poderoso de debbuger e uma IDE forte para resolver seus problemas, seja o CLion no Linux/Mac ou Visual Studio IDE no Windows, porem essas ferramentas são da forma que são pq elas são projetadas para grandes projetos que iram precisar de todo esse apoio. Porem para a maioria dos casos, especialmente se você ainda esta aprendendo C e se acostumando com ecosistema, utilizar uma IDE pode não atrapalhar, porem imagina querer utilizar um reator nuclear para acender uma lampada, e para isso você coloca o reator para funcionar a 0.1% da capacidade normal, você pode não estar utilizando o que não precisa, porem ainda vai ter o problema de iniciar o reator e se você apertar algum botão que não sabe oq faz pode acabar causando problemas. A não ser que você já saiba utilizar uma IDE, eu recomendo usar o VS Code, pois ele tem um dos melhores conjunto de plugins para C, mas qualquer Editor atualmente tera suporte para C.

## Flags de Compilação
### O que é uma flag de compilação
Esse é o fator mais facil de utilizar porem com maior impacto, se você for tirar algo desse post que seja essa seção. Existem  principais compiladores de C atualmente: GCC; MSVC e CLang. GCC(GNU Compiler Colletion) e o principal compilador atualmente, ele já vem instalado em todo Linux por padrão(Esclarecendo, GCC não é um compilador de C, mas sim uma coleção de compiladores, dentre eles C); MSVC(Microsft Visual C++) é o principal compilador de C++ para Windows, porem como o foco é C++ o suporte a C é limitado, para Windows ainda existe o MinGW(Minimal GNU for Windows), que é uma adptação do GCC para uso em Windows, que pode ser mais recomendado; CLang é o mais novo da lista, sendo comptaviel com GCC e MSVC. Eu uso Linux Mint, então por padrão utilizo o GCC, e é o que eu recomendo, por funcionar perfeitamente tanto para C quanto para C++. E para Windows recomendo o MinGW se você quiser utilizar C e não apenas C++.

Abrindo uma tangente importante rapidinho, pode ser estranho para alguem que não seja acostumado, pensar que existem tantos compiladores diferente para C. Porem é importante lembrar que ninguem é dono de C, como Python é da Python Foundantion; Go é da Google; Java é da Oracle... C é mantido e atualizado por um comite, que lançam como a linguagem deve se comportar, invês de um compilador para a linguagem, e as empresas que possuem compiladores atualizam os seus produtos para atender aos novos padrões. Irei falar mais sobre isso em outro post.

Todos esses compiladores possuem flags, muitas dessas flags originais do GCC por motivo de herança, e por GCC ser o primeiro grande compilador. Uma flag é uma forma de você indicar ao seu compilador que você quer que ele realize uma certa ação durante a compilação. Uma famosa é o -Ox, que indica ao compilador que você quer que ele otimize o codigo. Por exemplo, o codigo a seguir ao ser compilado sem otimização resulta no seguinte Assembly (você não precisa saber de Assembly, apenas de contar a quantidade de linhas é notavel a diferença). 

![n_otimizado](/assets/aprender_c/sem_otimização.png)

Enquanto o mesmo codigo, compiladro com -O1(primeiro nivel de otimização), resulta no seguinte Assembly.

![otimizado](/assets/aprender_c/otimizado.png)

A diferença entre o otimizado e não otimizado é gritante. Existem mais de 1000 flags diferentes no GCC, com diferentes objetivos, para diferentes plataformas e arquiteturas, algumas dessas flags são na verdade um pacote de diferentes flags, a flag -O1 que foi utilizada ativa outras 48 flags diferentes, caso queira ler sobre o link para a documentação estara na descrição. irei falar sobre as flags mais importantes, as de ajudam a detectar erros e falhas no seu codigo.

### -Wall, -Wextra e -Werror
-Wall(Warning All) ira ativar no minimo 55 verificações ao ao compilar o seu codigo, dentre essas verificações tera -Warray-compare, que ira detectar se você esta tentando compara 2 arrays de forma errada, -Wunused para dectar variaiveis é/ou funções definidas mas não utilizadas... A quantidade de verificações pode varias dependendo de varios fatores diferentes. -Wextra(Warning Extra) ira ativar mais 12 verificações extras, como por exemplo -Wstring-compare que verifica comparação entre strings ou -Wcast-function-type que verifica casting indevido de funções. Tanto -Wall quanto -Wextra iram adicionar avisos, o seu codigo pode compilar mesmo tendo 1 milhão de avisos de possiveis problemas, e para que você não possa ignorar esses problemas, é recomendado o uso do -Werror(Warning Error), que ira converter esses avisos para erros, ou sejá, enquanto você não corrigir todos os problemas detectados, o seu codigo não ira compilar. 

Isso pode parecer estranho "porque eu precisaria dizer que eu quero que o compilador verifique se meu codigo esta correto?", e a resposta é simples, verficações custa tempo e memoria, quanto mais verificações de segurança você realizar durante o processo de compilação, mais tempo ira demorar para o seu codigo compilar e mais memoria sera consumida, e algumas flags faram com que o binario final seja maior é/ou mais lento, e em projetos grandes como o Kernel do Linux; MacOS; Windows, ou coisas parecidas, esse tempo fara diferença. A ideia é utilizar essas flags para gerar builds de tests, e assim que todos os erros forem corrigidos, uma nova build sem as flags pode ser gerada, pois os erros já foram corrigidos. E o GCC já faz inumeras verificações por padrão, não é como se ele não verificace nada por padrão, apenas a parte menor precisa ser ativada manualmente.

Vamos ver na pratica a diferença que isso faz, aqui temos um exemplo de uma implementação de uma double linkedlist em C, que pode ser compilada normalmente sem nem um problema. (desculpe pelo bloco gigante de codigo)

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
} Node;

typedef struct {
    Node* head;
    Node* tail;
    int size;
} LinkedList;

int insertAtBeginning(LinkedList* list, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (!newNode) 
        printf("Erro de alocação de memória\n");
    
    newNode->data = data;
    newNode->next = list->head;
    newNode->prev = NULL;
    
    if (list->head != NULL)
        list->head->prev = newNode;
    else 
        list->tail = newNode;
    
    list->head = newNode;
    list->size++;
}

void printList(LinkedList* list, int verbose) {
    Node* current = list->head;
    printf("Lista: ");
    while (current != NULL) {
        printf("%d ", current->data);
        current = current->next;
    }
    printf("\n");
}

int findNode(LinkedList* list, int value) {
    Node* current = list->head;
    int position = 0;
    
    while (current != NULL) {
        if (current->data == value)
            return position;
    
        current = current->next;
        position++;
    }
}

void deleteList(LinkedList* list) {
    Node* current = list->head;
    Node* nextNode;
    
    while (current = list->head) {
        nextNode = current->next;
        free(current);
        current = nextNode;
    }
    
    list->head = NULL;
    list->tail = NULL;
    list->size = 0;
}

int getSize(LinkedList* list) {
    int size;
    if (list != NULL) 
        size = list->size;
    return size; 
}

void removeFromEnd(LinkedList* list) {
    if (list->tail == NULL) {
        return;
    }
    
    Node* toRemove = list->tail;
    
    list->tail = list->tail->prev;
    list->tail->next = NULL;
    
    free(toRemove);
    list->size--;
}

int main() {
    LinkedList list = {NULL, NULL, 0};
    int result;
    
    insertAtBeginning(&list, 10);
    insertAtBeginning(&list, 20);
    insertAtBeginning(&list, 30);
    
    printList(&list, 1); 
    
    int unusedVariable;
    
    result = findNode(&list, 20);
    printf("Encontrado na posição: %d\n", result);
    
    printf("Tamanho da lista: %d\n", getSize(&list));
    
    removeFromEnd(&list);
    printList(&list, 0);
    
    deleteList(&list);
    
    return 0;
}
``` 

Como dito, se você tentar compilar esse codigo (Com GCC), você não tera nem um warning ou erro.

![](/assets/aprender_c/sem_flags.png)

Porem, ao adicionar as flags, derrepente o codigo que antes parecia OK passou a não parecer tão OK assim.

![](/assets/aprender_c/com_flags.png)

Com o uso de apenas as 3 principais flags: -Wall; -Wextra e -Werror, nos já resolvemos muitos possiveis problemas de runtime em tempo de compilação, e pode parecer simples, porem esse simples, porem na minha opinião e de muitos, essas 3 flags precisam ser fixas sempre qeu você for compilar algo, e deveriam ser ensinadas antes mesmo de ensinar o Hello World. Existem inumeras outras flags para verificar possiveis erros e falhas no codigo, a documentação completa lista cada flag e o que ela faz, e existe mais do que conteudo o suficiente listando quais as melhores flags para se utilizar.

## GDB

OBS: Essa seção trata de ferramentas para Linux, que eu não posso garantir que iram funcionar corretamente no Windows e/ou MacOS, porem o Windows + WSL ira funcionar perfeitamente, Mac eu realmente não posso garantir nada infelizmente.

Ok ok, com as flags temos mais garantia sobre a consistencia e minima qualidade de codigo, porem isso não quer dizer que vamos ficar livres de bugs, vazamentos de memoria ou segfaults, elas se tornam mais dificeis, porem não impossiveis. Apos arrumarmos a nossa implementação, e adicionarmos mais algumas funcionalidades (mantendo o uso das flags -W*), chegamos a algo parecido com isso:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
} Node;

typedef struct {
    Node* head;
    Node* tail;
    int size;
} LinkedList;

void initList(LinkedList* list) {
    list->head = NULL;
    list->tail = NULL;
    list->size = 0;
}

void insertFront(LinkedList* list, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = list->head;
    
    if (list->head != NULL)
        list->head->prev = newNode;
    else
        list->tail = newNode;
    
    
    list->head = newNode;
    list->size++;
}

// Insere no final
void insertBack(LinkedList* list, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = list->tail;
    
    if (list->tail != NULL)
        list->tail->next = newNode;
    else
        list->head = newNode;
    
    
    list->tail = newNode;
    list->size++;
}

int removeFront(LinkedList* list) {
    if (list->head == NULL)
        return -1; 
    
    Node* temp = list->head;
    int data = temp->data;
    
    list->head = list->head->next;
    list->head->prev = NULL;
    
    free(temp);
    list->size--;
    
    return data;
}


int removeBack(LinkedList* list) {
    if (list->tail == NULL)
        return -1; 
    
    Node* temp = list->tail;
    int data = temp->data;
    
    list->tail = list->tail->prev;
    
    if (list->tail != NULL)
        list->tail->next = NULL;
    else
        list->head = NULL;
        
    free(temp);
    list->size--;
    
    return data;
}

void printList(LinkedList* list) {
    Node* current = list->head;
    printf("Lista [%d elementos]: ", list->size);
    while (current != NULL) {
        printf("%d ", current->data);
        current = current->next;
    }

    printf("\n");
}

void freeList(LinkedList* list) {
    Node* current = list->head;
    while (current != NULL) {
        Node* next = current->next;
        free(current);
        current = next;
    }

    list->head = NULL;
    list->tail = NULL;
    list->size = 0;
}

int main() {
    LinkedList list;
    initList(&list);
    
    insertFront(&list, 10);
    insertFront(&list, 20);
    insertBack(&list, 30);
    insertBack(&list, 40);
    
    printf("Lista inicial:\n");
    printList(&list);
    
    printf("\nRemovendo do início:\n");
    int val1 = removeFront(&list);
    printf("Removido: %d\n", val1);
    printList(&list);
    
    printf("\nRemovendo do final:\n");
    int val2 = removeBack(&list);
    printf("Removido: %d\n", val2);
    printList(&list);
    
    printf("\nRemovendo do início novamente:\n");
    int val3 = removeFront(&list);
    printf("Removido: %d\n", val3);
    printList(&list);
    
    int val4 = removeFront(&list);
    printf("Removido: %d\n", val4);
    printList(&list);
    
    freeList(&list);
    return 0;
}
```
E ao compilar, nem um erro é gerado, porem ao testar temos uma ingrata surpresa:

![](/assets/aprender_c/seg_fault.png)

Uma segmentaion fault, existem inumeros casos para que uma segfault aconteça, utilização de ponteiro nullo, acesso indevido a memoria, tentar escrever em memoria protegida... Nos sabemos que o erro esta na função `removeFront`, porem ao olhar a função não esta muito claro onde esta o erro, especilamente para um novato.

```c
int removeFront(LinkedList* list) {
    if (list->head == NULL)
        return -1; 
    
    Node* temp = list->head;
    int data = temp->data;
    
    list->head = list->head->next;
    list->head->prev = NULL;
    
    free(temp);
    list->size--;
    
    return data;
}
```

Para lidar com segmentaion fault, existem 3 formas, tentar reescrever de forma mais cuidadossa ate entender o problema, pedir ajuda a alguem, ou, ousar o GDB. GDB(GNU Debugger) é a principal ferramenta para tentar resolver bugs menos obvios em C/C++ e outras linguagens(primeiramente C/C++). O GDB é de longe uma das ferramentas mais complexas para ser utilizar no ecosistema, especialmente para um novato, tento funcionalidades para analisar o Assembly gerado comparado linha a linha com o codigo original, gerar break points, fazer execução instrução por instrução, verificar valores de cada variavel no seu programa, cada registrador do processador, cada endereço de memoria entre mil funcionalidades, e para piorar, 100% no terminal. Porem não tenha medo, pois eu já passei por este medo e estou aqui para lhe ensinar o que é necessario apenas para resolver segfaults de forma não tão complicada. Sera necessario apenas conhecer 3 comandos, run, print e exit. 

Para usar o GDB basta installar ele na sua maquina pelo seu gerenciador de pacotes. E para rodar o programa so passar o programa como parametro por linha de comando, o GDB ira carregar o seu programa e você pode ignorar todo o texto que aparecer e apenas digite `run` para rodar o programa dentro do GDB.

![](/assets/aprender_c/gdb_no_flag.png)

E não temos nada de util, apenas o mesmo de antes, um aviso de segfault, e um edereço de memoria que não ajuda em nada, isso por que para que o GDB consiga nos dar informações mais uteis, precisamos compilar o nosso codigo com uma outra flag, a `-g`. `-g` vai indicar ao compilador que você quer manter informações do codigo fonte dentro do binario, e que informações para debug sejam adicionadas durante a compilação. Repetindo o processo, porem dessa vez compilando com `-g`, temos algo muito mais util.

![](/assets/aprender_c/gdb_flag.png)

Agora sabemos exatamente onde o erro esta acontecendo, esta na linha 65, e podes ver que é algo envolvendo `list`. Vamos verificar qual o valor salvo em `list` com o comando `print`.

![](/assets/aprender_c/head_null.png)

E agora sabemos exatamente o problema, `head` é null, e estamos tentando acessar `prev` de `head` mesmo sendo null, o que causa uma segfault. E se você voltar na função, de fato, não existe nem uma verificação sobre `head` ser valido. Apos uma simples revisão na função `removeFront`, tudo funciona coretamente.

```c
int removeFront(LinkedList* list) {
    if (list->head == NULL)
        return -1; 
    
    Node* temp = list->head;
    int data = temp->data;
    
    list->head = list->head->next;
    if (list->head != NULL)
        list->head->prev = NULL;
    
    free(temp);
    list->size--;
    
    return data;
}
```
![](/assets/aprender_c/ok.png)


## Valgrind

Segfautls podem parecer ruim, porem uma sefgault é esta para um programa, igual a dor esta para o sistema nervoso, é importante saber que você se machucou ou esta doente, mas as vezes um problem pode vir sem dor, e você so ira perceber que esta mal depois de muito tempo. O quanto antes o seu programa crashar por segfault, mais tempo você tera para resolver. Porem as vezes você esta acessando memoria que não deveria, porem nada acontece, os eu programa não crasha ~~por enquanto~~. Ou você pode esta deixando um monte de valores na memoria sem limpa-los, o que ira acontecer com 100% de certeza. Para resolver problemas de memorias, que não iram diretamente crashar o seu programa, mas que são periogoso caso sejam ignorados, temos o Valgrind.

Enquanto o GDB é um cirurgiam, que so é chamado quando precisamos resolver algo que já aconteceu, Valgrind é o medico de checkup para impedir que este algo aconteça. O Valgrind é relativamente mais dificil de usar que o GDB, mesmo que o GDB sejá mais complexo, você apenas precisa 

## Comunidade