---
layout: post
title: "Infdev #04 - Ponteiros em C."
categories: [C, Ponteiros]
tags: [C, Ponteiros]
---

No ultimo post (Infdev #03 - Memória RAM e Endereços.), nos falamos sobre como a memoria funciona. Agora, vamos entender como C lidar com ponteiros (E não C++ neste caso, pois C++ possui diferentes formas de lidar com ponteiros), e sobre alguns fatores importantes que acabam sendo ignorados por materiais menos aprofundados. 

> Aviso: não irei falar sobre o uso de ponteiros para alocar memoria na heap, pois o proximo post sera justamente sobre stack vs heap, e eu acredito que entender stack vs heap é mais facil apos entender o uso de ponteiros.

## O que é um ponteiros?
Um ponteiro em C é um tipo, um tipo para designar variaveis/constantes que invês de armazenar um valor, armazenam um endereço de memoria. Por exemplo:

```c
#include <stdio.h>

int main() {
    int       foo = 10;
    int *ponteiro = &foo; // & indica que queremos o endereço de memoria de foo, e não o valor armazenado em foo   
                          // * indica que a variavel guarda um endereço de memoria

    printf("               Valor guardado em `foo`: %d\n", foo);
    printf("     Endereço de memoria de para `foo`: %p\n", &foo);
    printf("          Valor guardado em `ponteiro`: %p\n", ponteiro);
    printf("Endereço de memoria de para `ponteiro`: %p\n", &ponteiro);

    return 0;
}
```

Este exemplo, cria um valor na memoria nomeado `foo`, com valor de 10. E em seguida criamos um ponteiro que armazena para foo. Explicando melhor a sintaxe da criação de ponteiros: `int *ponteiro = &foo` pode parecer complicado, porem tal como `int foo` cria um valor na memoria que armazena um inteiro, `int *ponteiro` cria um valor na memoria que armazena um endereço de memoria de um inteiro, e não um inteiro. E sim, como o ponteiro é uma variavel como qualquer outra, o valor que armazena o ponteiro, também possui um endereço de memoria que pode ser armazenado em um ponteiro caso você queira
```c
int main() {
    int       foo = 10;
    int       *p1 = &foo;
    int      **p2 = &p1;
    int     ***p3 = &p2;
    int    ****p4 = &p3;
    ...
```
> Existem varios casos onde o uso de ponteiros que apontam para outros ponteiros é util, para lidar com matrizes ou listas de strings, mas isso fica para outros posts.
{: .prompt-tip }

## Uso
O principal uso de ponteiros, é permite acesso a um valor sem precisar mover ou duplica, como por exemplo, para lidar com listas grandes:
```c
int sum(int *x, int len) {
    int total = 0;
    for (int i = 0; i < len; i++)
        total += x[i];
    return total;
}

void square(int *x, int len) {
    for (int i = 0; i < len; i++)
        x[i] = x[i] * x[i];
}

void print_lista(int *x, int len) {
    printf("Lista: ");
    for (int i = 0; i < len; i++)
        printf("%d ", x[i]);
    printf("\n");
}

int main() {
    int lista[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int len = sizeof(lista)/sizeof(int); // sizeof(lista) indica o tamanho da lista em bytes, sizeof(int) diz o tamanho de um int em bytes
     
    int total = sum(&lista[0], len); // & indica que quermos o endereço de memoria de lista[0]. e não o valor
    print_lista(&lista[0], len);     // Lista: 1 2 3 4 5 6 7 8 9 10
    printf("Total = %d\n", total);   // Total = 55
    
    square(&lista[0], len);

    int total_quadrado = sum(&lista[0], len);
    print_lista(&lista[0], len);            // Lista: 1 4 9 16 25 36 49 64 81 100 
    printf("Total = %d\n", total_quadrado); // Total = 385
    return 0;
}
```
Neste exemplo, temos uma lista de inteiros com varios valores, e queremos fazer coisas com ela, printar todos os elementos, somar os elementos, operar sobre os elementos... Nessas operações, o uso de ponteiros serve principalmente para economizar memoria, pois caso não fosse utilizado ponteiros, sempre que uma função fosse chamada, uma nova copia do array seria criada, e seria passada para a função como parametro. E especilamente no caso de operar sobre os elementos da lista, o ponteiro é utilizado para acessar o valor original, e não uma copia, pois queremos editar a lista original, e não gerar uma nova, com ponteiros é possivel.

Agora, algo que pode esta confuso, é a sintaxe de passar o ponteiro do primeiro elemento, invês da lista, e as funções recebem um ponteiro de um inteiro, e não de uma lista de inteiros, e é agora que vamos falar do principal aspecto de ponteiros que custuma ser ignorada, ou mal explicada, artimetica de ponteiros.

## Aritmética de ponteiro
Você já se perguntou o porque de indexes de arrays começarem em 0 e não em 1? Isso é por calsa de como arrays são armazenados na memoria e pela Aritmética de ponteiro. Vamos lembrar do que foi dito no ultimo post, o Infedev #03 sobre memoria, a memoria é um grande array, e os ponteiros são endereços de memoria que servem de index para este array. O endereço de memoria é apenas um numero, e apenas isso, um numero muito grande em hexadecimal, mas um numero, e como qualquer outro numero, podemos realizar somas e subtrações (as outras operações são possiveis, mas não são uteis). Quando um conjunto de valores são alocados na memoria, seja um array, ou uma estrutura, todos os valores deste conjunto sera alocados sequencialmente, um seguido do outro, sem espaços vazios entre os elementos. 
```c 
int main() {

    int lista[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    return 0;
}
```

Quando a lista foo é alocada na memoria, os 10 elementos seram colocados na memoria de forma sequencial, por exemplo, o primeiro elemento esta alocado em 0xFF00, como o tipo int em C possui 4 bytes, o segundo elemento estara na posição 0xFF04, o terceiro no endereço 0xFF08, o proximo em 0xFF0C e assim por diante. 
```c 
void square(int *x, int len) {
    for (int i = 0; i < len; i++)
        x[i] = x[i] * x[i];
}

int main() {

    int lista[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    square(&lista[0], len);

    return 0;
}
```

A sintaxe de &lista[0] pode ser meio confusa, e realmente é sem o contexto, e se você utilizar &lista, invês de &lista[0], vai funcionar, porem o compilador vai te dar um warning, pois a função square espera receber um ponteiro para um int, &lista é um ponteiro para int[10]. Ao passar um ponteiro para o primeiro valor da lista, junto ao tamanho da lista, nos sabemos quantos valores a lista tem, e podemos ir somando 4 (tamanho em bytes de um int) a cada etapa para acessar os proximos elementos. Agora, algo que precisa ser explicado e a sintaxe de acesso a elementos de um array. A sintaxe de lista[index], so funciona se soubermos o tipo dos valores armazenados em lista, e o tamanho de cada valor, e a forma com que o index é acessado, é multiplicado index pelo tamanho, e somando o primeiro endereço de memoria de lista. Por exemplo:
```c
int main() {
    int lista[] = {1, 2, 3, 4};
    lista[2] = 50; 
}
```
Vamos supor que a lista esta alocado do endereço 0xFF00, nos sabemos que é uma lista int's, e sabemos que um int possui 4 bytes, nos queremos o index 2 (terceiro elemento), para acessar o index desejado, pegamos o endereço incial do array (o endereço a qual esta o primeiro elemento/index 0), e somamos com 4 * index: 0xFF00 + (4 * 2) = 0xFF00 + 8 = 0xFF08. Logo, o index 2(terceiro elemento), esta no endereço 0xFF08. Esse comportamento gera algumas consequencias, uma delas é a velocidade, arrays são tão mais rapidos que qualquer outra estrutura de dados justamente pq podemos acesar qualquer valor dele diretamente, apenas realizando uma multiplicação e uma soma. E uma segunda consequencia, é o motivo de que o primeiro elemento de um array é o 0 e não o 1, pois o primeiro já esta no endereço inicial do array.


Algo importante a se dar foco é a questão do tamanho do dado a qual o ponteiro aponta. No exemplo da lista, o ponteiro aponta para um int, que possui 4 bytes de tamanho, porem um ponteiro pode apontar para qualquer literalmente coisa na memoria, independete do tipo, seja um um valor primitido como int ou float, seja uma estrutura com varios valores dentro, podemos ate ter ponteiros para funções. Como dito anteriormente o ponteiro sempre tera o mesmo tamanho, porem o valor apontado pode variar.

```c
typedef struct Context {
    int eip; // 4 bytes        
    int esp; // 4 bytes       
    int ebx; // 4 bytes       
    int ecx; // 4 bytes       
    int edx; // 4 bytes       
    int esi; // 4 bytes       
    int edi; // 4 bytes       
    int ebp; // 4 bytes       
    int pc;  // 4 bytes   
} Context;   // 36 bytes

int main() {
    Context  c = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    Context *p = &p;
    
    printf("Tamanho de Context: %d\n", sizeof(c));              // 36
    printf("Tamanho de Ponteiro de Context: %d\n", sizeof(p));  // 8
    
    return 0;
}
```

Neste exemplo, a estrutura Context ocupa 36 bytes na memoria, porem o ponteiro ocupa apenas 8 como esperado. Caso queira criar uma lista de Context, basta criar tal como criamos uma lista de ints, o compilador ira se encarregar de realizar a aritmetria para acessar qualquer valor indexado.

```c
typedef struct Context {
    int eip; // 4 bytes        
    int esp; // 4 bytes       
    int ebx; // 4 bytes       
    int ecx; // 4 bytes       
    int edx; // 4 bytes       
    int esi; // 4 bytes       
    int edi; // 4 bytes       
    int ebp; // 4 bytes       
    int pc;  // 4 bytes   
} Context;   // 36 bytes

int main() {
    Context contextos[] = { ... };
    ...

    contextos[3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    ...
    return 0;
}
```

## Ponteiros de funções
Assim como qualquer outra coisa no seu programa, funções estão carregadas na memoria, estando em algum lugar na memoria, podemos acessar esse lugar com o endereço de memoria correto, portanto, podemos utilizar ponteiros para funções. A sintaxe de ponteiros para funções é um pouco diferente, quase sempre funções precisam parametros, por exemplo:

```c
int soma(int x, int y) {
    return x + y;
}

int mult(int x, int y) {
    return x * y;
}
```

Ambas funções soma e mult recebem 2 inteiros e retornam um inteiro, por mais que elas possuam corpos diferentes, porem oq importa para ponteiros, é apenas o tipo de retorno, e os tipos dos parametros. Para mostrar, vamos voltar ao exemplo anterior da lista.

```c
#include <stdio.h>

int soma_20(int x) {
    return x + 20;
}

int quadrado(int x) {
    return x * x; 
}

void apply(int *x, int len, int (*fun)(int)) {
    for (int i = 0; i < len; i++)
        x[i] = fun(x[i]);
}

void print_lista(int *x, int len) {
    printf("Lista: ");
    for (int i = 0; i < len; i++)
        printf("%d ", x[i]);
    printf("\n");
}

int main() {
    int lista[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int len = sizeof(lista)/sizeof(int); // sizeof(lista) indica o tamanho da lista em bytes, sizeof(int) diz o tamanho de um int em bytes
     
    print_lista(&lista[0], len);      // Lista: 1 2 3 4 5 6 7 8 9 10
    
    apply(&lista[0], len, &quadrado);
    print_lista(&lista[0], len);      // Lista: 1 4 9 16 25 36 49 64 81 100 

    apply(&lista[0], len, &soma_20);
    print_lista(&lista[0], len);      // Lista: 21 24 29 36 45 56 69 84 101 120 

    return 0;
}
```